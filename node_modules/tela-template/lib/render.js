/** The template handles all of the rendering and updates thrown
 * at it from the view.
 *
 * The main link between them is the oncomponent function and the prop function.
 * The former is called when a component is found on the initial render. This allows
 * you to set callbacks for when to update it. The latter is a function defined by
 * the view that returns the data needed given a string like 'user.name'. The template
 * should return 'Colin Walker'.
 *
 * Overall, the template takes a string and parses it into a dom structure. Then,
 * when you call render, it loops through and inserts the data it finds with the `prop`
 * function. Then, it caches this version in `this.rendered`. When an element is updated,
 * determined by the view, the view can just call template.update(id) to update this element
 * in the cached rendered template and the shadow DOM. When we navigate to a new route, the
 * view can call `render` everytime and immediately get the latest template.
 *
 * Formulas handle the rendering of each individual component. This allows separation, where
 * a component is defined merely with an object, so a cache can be established on the server,
 * and used on the client.
 **/

'use strict'
const formulas = require('./formulas')
const parse = require('./parser')

class Template {
  constructor(tpl, serverCache) {
    this.template = tpl
    this.cache = serverCache || {}
    this.dom = parse(tpl)
    this.rendered = null
    this.hasServerCache = serverCache ? true : false
  }

  /** prop provides the connection to the view. by returning the data requested
   * by the template argument. For example:
   * > prop('user.name') //=> should return currentView.user.name
   **/
  prop(arg) {}

  /** Load all of the components into the dom and into the cache.
   * This loops through all of the defined components, renders from the
   * formula, and places a placeholder to reference them from the cache.
   * */
  loadComponents() {
    // search for all element that have an attribute called each
    this.dom.search( (el) => { return el.attrs.each } ).forEach((el) => {
      var spl = el.attrs.each.split('in')
      if (!spl[1]) { console.warn('each iterations must be: user in users, no "in" found') ; return }

      delete el.attrs.each // remove each from attributes
      var id = el.attrs.id || 'tl'+Math.random().toString(36).substr(2, 36)

      // load data into the cache
      this.cache[id] = {
        params: {data: spl[1].trim(), text: el.html, root: spl[0].trim()},
        element: el, // original element for good measure
        formula: 'each'
      }

      el.remove() // remove this element.

      // render the formula as is and insert into the template
      var res = formulas.each.apply(this, [id, this.cache[id].params, this.cache[id].element])
      el.parent.add(`<span id="${id}">${res}</span>`, el.parent.children.indexOf(el) - 1)
    })

    // search for all elements that have {{ }} inside them.
    this.dom.search( (el) => { return el.binding } ).map((el) => {
      var id = el.attrs.id || 'tl'+Math.random().toString(36).substr(2, 36)

      this.cache[id] = {
        params: {text: el.value},
        element: el,
        formula: 'bindings'
      }

      // render the formula and insert into the template
      var res = formulas.bindings.apply(this, [id, this.cache[id].params, this.cache[id].element])
      var ins = parse(`<span id="${id}">${res}</span>`).children[0]
      el.parent.children[el.parent.children.indexOf(el)] = ins
    })
  }

  /** updating from the cache.
   * Just call this with the id you want to update. You
   * should store the ID in your callbacks and reactions.
   * This updates the cached rendered template on every call to update.
   * */
  update(id) {
    if (this.cache[id]) {
      var res = formulas[this.cache[id].formula].apply(this, [id, this.cache[id].params, this.cache[id].element])

      var el = this.dom.search((el) => {return el.attrs.id === id})[0]

      // set the element referenced by the id in the dom to be part of the dom.
      this.dom.search((el) => {return el.attrs.id === id})[0].html = res

      // re render the dom and cache it
      this.rendered = this.dom.html

      // if the element exists in the document we also insert it there.
      if (typeof document !== 'undefined' && document.getElementById(id)) {
        document.getElementById(id).innerHTML = res
      }
    }
  }

  /** updates all elements in the cache */
  updateAll() {
    Object.keys(this.cache).forEach((id) => { this.update(id) })
  }

  /** Rendering the template.
   * This provides the logic for rendering the template when ready.
   * NOTE, when render is called, it will not update the rendered template,
   * it expects the callbacks to call update for each referenced element.
   * */
  render() {
    // if we do not have a rendered template cached.
    if (!this.rendered) {
      if (this.hasServerCache) {
        this.dom = parse(document.getElementById('main').innerHTML)
        this.rendered = this.dom.html
      } else {
        this.loadComponents()
        this.rendered = this.dom.html
      }
    }

    // this should be an up to date cache of all changes.
    return this.rendered
  }

}


let temp = `
  <p>
    Hello there everyone, this is a pretty cool thing <small>hello</small>{{ hello if user }}.
    <a href="hello">This is some cool stuff</a>
  </p>

  <ul>
    <li each="user in users">{{ user.name if user.nothing }}</li>
    <li>Hello there</li>
  </ul>
`

var users = [
  {name: 'Colin'},
  {name: 'Colin'},
  {name: 'Colin'},
  {name: 'Colin'},
  {name: 'Colin'}
]
var greet = 'hello'

var t = new Template(temp)
t.prop = function(arg) {
  if (arg == 'users') {
    return users
  } else {
    return greet
  }
}


console.log(t.render())
users[0].name = 'Colin the greatest'
greet = 'something else'

t.updateAll()

console.log(t.render())
