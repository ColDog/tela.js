/** These formulas separate the logic of building each component in a
 * template, from the actual parameters defined by the template. This
 * allows us to easily cache the template parameters, and then just run
 * them through this formula repeatedly when they are stale.
 *
 * It also allows for the server to define the cache of components, meaning
 * we don't need to do a full re-render on load.
 * */
const formulas = {

  each: function(id, params) {
    var list = ''
    this.prop(params.data).forEach( (x) => {
      list += replaces(params.text, (arg) => {
        if (arg.split('.')[0].trim() === params.root) {
          return Function(params.root, 'return ' + arg)(x)
        } else {
          return this.prop(arg)
        }
      })
    })
    return list
  },

  bindings(id, params) {
    return replaces(params.text, this.prop)
  }

}

module.exports = formulas

/** Method for replacing {{ }} with bindings in a string
 * Just simply splits the string by {{ }}, and maps through,
 * passing the elements which had {{ }} around them to the
 * function provided and returning those that didn't.
 * */
var replaces = function(string, fn) {
  return string.split(/\{([^}}]+)?}}/g).map((arg) => {
    if (arg[0] === '{') {
      arg = arg.replace('{', '').trim()

      // finds an unless statement.
      if (arg.match(/unless/)) {
        var p = arg.split('unless')
        if ( !fn(p[1]) ) { return fn(p[0]) }
      }

      // finds an if statment, first checks this with prop.
      else if (arg.match(/if/)) {
        var i = arg.split('if')
        if ( fn(i[1]) ) { return fn(i[0]) }
      }

      // no if or unless statements
      else { return fn(arg) }
    } else {
      return arg
    }
  }).join('')
}


'user === person'